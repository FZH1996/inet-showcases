<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<analysis version="2">
    <inputs>
        <input pattern="results/NonQos-#0.vec"/>
        <input pattern="results/NonQos-#0.sca"/>
        <input pattern="results/Qos-#0.vec"/>
        <input pattern="results/Qos-#0.sca"/>
    </inputs>
    <charts>
        <chart name="End-to-end delay, non-qos" script="import results&#10;import chart&#10;import matplotlib.pyplot as plt&#10;import numpy as np&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.server.app[0]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[1]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[2]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[3]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*)))&quot;&quot;&quot;&#10;&#10;df = results.getVectors(filter_string)&#10;&#10;df = results.transform_results(df)&#10;&#10;&#10;&#10;modulenames = list(df.index.get_level_values('module'))&#10;props = {'X.Axis.Min': '0.5', 'Line.Name/QosThroughput.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[3]': 'voice', 'Line.Name/QosShowcase.server.app[0]': 'background', 'Y.Axis.Title': 'End-to-end delay [s]', 'Line.Name/QosThroughput.server.app[0]': 'background', 'Line.Name/QosShowcase.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[3]': 'voice', 'Graph.Title': 'End-to-end delay, equal bitrate non-qos', 'Legend.Display': 'true', 'X.Axis.Title': 'Time [s]'}&#10;&#10;names = [props[&quot;Line.Name/&quot; + i] for i in modulenames]&#10;&#10;# keys = [&quot;Line.Name/&quot; + i for i in modulenames]&#10;# names = [props[k] if k in props else &quot;default&quot; for k in keys]&#10;&#10;print(&quot;HERE:&quot;,df.result.vecvalue)&#10;&#10;print(np.std(df.result.vecvalue[0]))&#10;&#10;print(&quot;average delay:&quot;)&#10;for i in df.result.vecvalue:&#10;    print(np.mean(i))&#10;&#10;print(names)&#10;df[('attr','title')] = names&#10;&#10;plt.figure(figsize=(7.5,4))&#10;&#10;for ind, row in df.iterrows():&#10;    times = row[('result', 'vectime')]&#10;    values = row[('result', 'vecvalue')]&#10;    label = row[('attr', 'title')]&#10;    print(label)&#10;    plt.plot(times, values, linewidth=0, marker='.', markersize=2, label=label)&#10;plt.legend()&#10;plt.tight_layout(1.5)&#10;&#10;ymin, ymax = plt.ylim()&#10;xmin, xmax = plt.xlim()&#10;&#10;plt.ylim(0, 0.2)&#10;plt.xlim(0.5,xmax)&#10;&#10;ticklocs, ticklabels = plt.yticks()&#10;&#10;print(&quot;ticks: &quot;, ticklocs, ticklabels)&#10;&#10;#plt.yticks([0, 0.5, 1, 1.5, 2])&#10;&#10;plt.grid(b=True, which='major', axis='both', linestyle='--')&#10;&#10;plt.xlabel('Time [s]')&#10;plt.ylabel('End-to-end delay [s]')&#10;plt.title('End-to-end delay, non-QoS')&#10;&quot;&quot;&quot;&#10;chart.setProperty('X.Axis.Title', 'Time')&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;chart.setProperty('Line.Title/QosThroughput.server.app[3]', 'voice')&#10;print(chart.getProperties())&#10;print(chart.getDefaultProperties())&#10;&quot;&quot;&quot;&#10;&#10;plt.savefig('delay_nonqos.png', dpi=150, transparent=True)&#10;" type="MatplotlibChart"/>
        <chart name="End-to-end delay, qos" script="import results&#10;import chart&#10;import matplotlib.pyplot as plt&#10;import numpy as np&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.server.app[0]) AND name(endToEndDelay:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[1]) AND name(endToEndDelay:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[2]) AND name(endToEndDelay:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[3]) AND name(endToEndDelay:vector) AND file(*results/Qos-*)))&quot;&quot;&quot;&#10;&#10;df = results.getVectors(filter_string)&#10;&#10;df = results.transform_results(df)&#10;&#10;&#10;&#10;modulenames = list(df.index.get_level_values('module'))&#10;props = {'X.Axis.Min': '0.5', 'Line.Name/QosThroughput.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[3]': 'voice', 'Line.Name/QosShowcase.server.app[0]': 'background', 'Y.Axis.Title': 'End-to-end delay [s]', 'Line.Name/QosThroughput.server.app[0]': 'background', 'Line.Name/QosShowcase.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[3]': 'voice', 'Graph.Title': 'End-to-end delay, equal bitrate non-qos', 'Legend.Display': 'true', 'X.Axis.Title': 'Time [s]'}&#10;&#10;names = [props[&quot;Line.Name/&quot; + i] for i in modulenames]&#10;&#10;# keys = [&quot;Line.Name/&quot; + i for i in modulenames]&#10;# names = [props[k] if k in props else &quot;default&quot; for k in keys]&#10;&#10;print(&quot;average delay:&quot;)&#10;for i in df.result.vecvalue:&#10;    print(np.mean(i))&#10;&#10;print(names)&#10;df[('attr','title')] = names&#10;&#10;plt.figure(figsize=(7.5,4))&#10;&#10;for ind, row in df.iterrows():&#10;    times = row[('result', 'vectime')]&#10;    values = row[('result', 'vecvalue')]&#10;    label = row[('attr', 'title')]&#10;    print(label)&#10;    plt.plot(times, values, linewidth=0, marker='.', markersize=2, label=label)&#10;plt.legend()&#10;plt.tight_layout(1.5)&#10;&#10;ymin, ymax = plt.ylim()&#10;&#10;plt.ylim(ymin, 2)&#10;&#10;ticklocs, ticklabels = plt.yticks()&#10;&#10;print(&quot;ticks: &quot;, ticklocs, ticklabels)&#10;&#10;plt.yticks([0, 0.5, 1, 1.5, 2])&#10;&#10;plt.grid(b=True, which='major', axis='both', linestyle='--')&#10;&#10;plt.xlabel('Time [s]')&#10;plt.ylabel('End-to-end delay [s]')&#10;plt.title('End-to-end delay, QoS')&#10;&quot;&quot;&quot;&#10;chart.setProperty('X.Axis.Title', 'Time')&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;chart.setProperty('Line.Title/QosThroughput.server.app[3]', 'voice')&#10;print(chart.getProperties())&#10;print(chart.getDefaultProperties())&#10;&quot;&quot;&quot;&#10;&#10;plt.savefig('delay_qos.png', dpi=150, transparent=True)" type="MatplotlibChart"/>
        <chart name="Instantaneous packet delay variation, non-qos" script="import results&#10;import chart&#10;import matplotlib.pyplot as plt&#10;import numpy as np&#10;&#10;import solid_at_zero as saz&#10;#from solid_on_zero.py import solid_at_zero&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.server.app[0]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[1]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[2]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[3]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*)))&quot;&quot;&quot;&#10;&#10;df = results.getVectors(filter_string)&#10;&#10;df = results.transform_results(df)&#10;&#10;df.result['vecvalue'] *= 1000&#10;&#10;&#10;&#10;modulenames = list(df.index.get_level_values('module'))&#10;props = {'X.Axis.Min': '0.5', 'Line.Name/QosThroughput.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[3]': 'voice', 'Line.Name/QosShowcase.server.app[0]': 'background', 'Y.Axis.Title': 'End-to-end delay [s]', 'Line.Name/QosThroughput.server.app[0]': 'background', 'Line.Name/QosShowcase.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[3]': 'voice', 'Graph.Title': 'End-to-end delay, equal bitrate non-qos', 'Legend.Display': 'true', 'X.Axis.Title': 'Time [s]'}&#10;&#10;names = [props[&quot;Line.Name/&quot; + i] for i in modulenames]&#10;&#10;# keys = [&quot;Line.Name/&quot; + i for i in modulenames]&#10;# names = [props[k] if k in props else &quot;default&quot; for k in keys]&#10;&#10;print(&quot;------------------------------------------------------------&quot;)&#10;print(&quot;average jitter [ms]:&quot;)&#10;for i in df.result.vecvalue:&#10;    print(np.std(i))&#10;print(&quot;------------------------------------------------------------&quot;)&#10;&#10;print(names)&#10;df[('attr','title')] = names&#10;&#10;for i in range(0,df.result['vecvalue'].shape[0]):&#10;    vals = df.result['vecvalue'][i]&#10;        &#10;    difference = [vals[x] - vals[x-1] for x in range(0,len(vals))]&#10;    difference[0] = vals[0]&#10;    &#10;    df.result['vecvalue'][i] = difference&#10;&#10;plt.figure(figsize=(7.5,4))&#10;&#10;for ind, row in df.iterrows():&#10;    times = row[('result', 'vectime')]&#10;    values = row[('result', 'vecvalue')]&#10;    label = row[('attr', 'title')]&#10;    print(label)&#10;    plt.plot(times, values, linewidth=0, marker='.', markersize=2, label=label)&#10;plt.legend(loc=1)&#10;plt.tight_layout(1.5)&#10;&#10;#ymin, ymax = plt.ylim()&#10;&#10;xmin, xmax = plt.xlim()&#10;&#10;#plt.ylim(-0.05, 0.05)&#10;#plt.ylim(-0.15, 0.15)&#10;&#10;#-----------------------------------&#10;ZOOMED = False&#10;&#10;if ZOOMED:&#10;    y = 15&#10;else:&#10;    ymin, ymax = plt.ylim()&#10;    y = max(abs(ymin),abs(ymax))&#10;&#10;plt.ylim(-y,y)&#10;plt.xlim(0.5,xmax)&#10;#-----------------------------------&#10;&#10;ticklocs, ticklabels = plt.yticks()&#10;&#10;print(&quot;ticks: &quot;, ticklocs, ticklabels)&#10;&#10;#plt.yticks([0, 0.5, 1, 1.5, 2])&#10;&#10;plt.grid(b=True, which='major', axis='both', linestyle='--')&#10;&#10;ax = plt.gca()&#10;&#10;a = ax.get_ygridlines()&#10;&#10;# get default grid color&#10;ygridlines = ax.get_ygridlines()&#10;default_grid_color = ygridlines[2].get_color()&#10;&#10;saz.solid_at_zero(ax,default_grid_color)&#10;&#10;# zoom level change event handling&#10;def on_xlims_change(axes):&#10;    print(&quot;plt.xlim&quot; + str(ax.get_xlim()))&#10;    saz.solid_at_zero(ax,default_grid_color)&#10;&#10;def on_ylims_change(axes):&#10;    print(&quot;plt.ylim&quot; + str(ax.get_ylim()))&#10;    saz.solid_at_zero(ax,default_grid_color)&#10;    &#10;ax.callbacks.connect('xlim_changed', on_xlims_change)&#10;ax.callbacks.connect('ylim_changed', on_ylims_change)&#10;&#10;# solid line at y=0&#10;&#10;# get default grid color&#10;#ygridlines = ax.get_ygridlines()&#10;#default_grid_color = ygridlines[2].get_color()&#10;&#10;#def solid_at_zero():&#10;#    a = ax.get_ygridlines()&#10;#    ticklocs, ticklabels = plt.yticks()&#10;#    print(&quot;gridlines:&quot;,a)&#10;    &#10;#    j = 0&#10;#    r = 0&#10;    # set everything to default here&#10;#    plt.grid(linestyle='--',color=default_grid_color)&#10;    &#10;#    for i in ticklocs:&#10;#        if i == 0.0:&#10;#            #print(&quot;found 0 at &quot;,j)&#10;#            r = j&#10;#            b = a[r]&#10;#            b.set_color('black')&#10;#            b.set_linestyle('solid')&#10;#        j += 1&#10;    &#10;#solid_at_zero()&#10;&#10;#b = a[3]&#10;#b.set_color('black')&#10;#b.set_linestyle('solid')&#10;&#10;plt.xlabel('Time [s]')&#10;plt.ylabel('Instantaneous packet delay variation [ms]')&#10;plt.title('Instantaneous packet delay variation, non-QoS')&#10;&quot;&quot;&quot;&#10;chart.setProperty('X.Axis.Title', 'Time')&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;chart.setProperty('Line.Title/QosThroughput.server.app[3]', 'voice')&#10;print(chart.getProperties())&#10;print(chart.getDefaultProperties())&#10;&quot;&quot;&quot;&#10;&#10;plt.savefig('jitter_nonqos.png', dpi=150, transparent=True)&#10;" type="MatplotlibChart"/>
        <chart name="Instantaneous packet delay variation, qos" script="import results&#10;import chart&#10;import matplotlib.pyplot as plt&#10;import numpy as np&#10;&#10;import solid_at_zero as saz&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.server.app[0]) AND name(endToEndDelay:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[1]) AND name(endToEndDelay:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[2]) AND name(endToEndDelay:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[3]) AND name(endToEndDelay:vector) AND file(*results/Qos-*)))&quot;&quot;&quot;&#10;&#10;df = results.getVectors(filter_string)&#10;&#10;df = results.transform_results(df)&#10;&#10;df.result['vecvalue'] *= 1000&#10;&#10;&#10;&#10;modulenames = list(df.index.get_level_values('module'))&#10;props = {'X.Axis.Min': '0.5', 'Line.Name/QosThroughput.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[3]': 'voice', 'Line.Name/QosShowcase.server.app[0]': 'background', 'Y.Axis.Title': 'End-to-end delay [s]', 'Line.Name/QosThroughput.server.app[0]': 'background', 'Line.Name/QosShowcase.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[3]': 'voice', 'Graph.Title': 'End-to-end delay, equal bitrate non-qos', 'Legend.Display': 'true', 'X.Axis.Title': 'Time [s]'}&#10;&#10;names = [props[&quot;Line.Name/&quot; + i] for i in modulenames]&#10;&#10;# keys = [&quot;Line.Name/&quot; + i for i in modulenames]&#10;# names = [props[k] if k in props else &quot;default&quot; for k in keys]&#10;&#10;print(&quot;------------------------------------------------------------&quot;)&#10;print(&quot;average jitter [ms]:&quot;)&#10;for i in df.result.vecvalue:&#10;    print(np.std(i))&#10;print(&quot;------------------------------------------------------------&quot;)&#10;&#10;print(names)&#10;df[('attr','title')] = names&#10;&#10;for i in range(0,df.result['vecvalue'].shape[0]):&#10;    vals = df.result['vecvalue'][i]&#10;        &#10;    difference = [vals[x] - vals[x-1] for x in range(0,len(vals))]&#10;    difference[0] = vals[0]&#10;    &#10;    df.result['vecvalue'][i] = difference&#10;&#10;plt.figure(figsize=(7.5,4))&#10;&#10;for ind, row in df.iterrows():&#10;    times = row[('result', 'vectime')]&#10;    values = row[('result', 'vecvalue')]&#10;    label = row[('attr', 'title')]&#10;    print(label)&#10;    plt.plot(times, values, linewidth=0, marker='.', markersize=2, label=label)&#10;plt.legend(loc=1)&#10;plt.tight_layout(1.5)&#10;&#10;plt.grid(b=True, which='major', axis='both', linestyle='--')&#10;&#10;#ymin, ymax = plt.ylim()&#10;&#10;#plt.ylim(-0.25, 0.25)&#10;#plt.ylim(-0.02, 0.02)&#10;#y = 15&#10;#plt.ylim(-y,y)&#10;&#10;xmin, xmax = plt.xlim()&#10;plt.xlim(0.5,xmax)&#10;&#10;#-----------------------------------&#10;ZOOMED = False&#10;&#10;if ZOOMED:&#10;    y = 15&#10;else:&#10;    ymin, ymax = plt.ylim()&#10;    y = max(abs(ymin),abs(ymax))&#10;&#10;plt.ylim(-y,y)&#10;#-----------------------------------&#10;&#10;#----------------------------------------------------------------------------&#10;&#10;ax = plt.gca()&#10;&#10;# get default grid color&#10;ygridlines = ax.get_ygridlines()&#10;default_grid_color = ygridlines[0].get_color()&#10;&#10;saz.solid_at_zero(ax,default_grid_color)&#10;&#10;# zoom level change event handling&#10;def on_xlims_change(axes):&#10;    print(&quot;plt.xlim&quot; + str(ax.get_xlim()))&#10;    saz.solid_at_zero(ax,default_grid_color)&#10;&#10;def on_ylims_change(axes):&#10;    print(&quot;plt.ylim&quot; + str(ax.get_ylim()))&#10;    saz.solid_at_zero(ax,default_grid_color)&#10;    &#10;ax.callbacks.connect('xlim_changed', on_xlims_change)&#10;ax.callbacks.connect('ylim_changed', on_ylims_change)&#10;&#10;# set xlim/ylim here to get a specific zoom level image&#10;#plt.xlim(1, 1.84)&#10;#plt.ylim(-2.3, 3.8)&#10;#plt.tight_layout(2.5)&#10;&#10;left, right = plt.xlim()&#10;bottom, top = plt.ylim()&#10;&#10;# uncomment when zoomed&#10;#plt.ylim(bottom,top*1.1)&#10;&#10;print(left)&#10;print(right)&#10;print(bottom)&#10;print(top)&#10;&#10;#----------------------------------------------------------------------------&#10;&#10;plt.xlabel('Time [s]')&#10;plt.ylabel('Instantaneous packet delay variation [ms]')&#10;plt.title('Instantaneous packet delay variation, QoS')&#10;&quot;&quot;&quot;&#10;chart.setProperty('X.Axis.Title', 'Time')&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;chart.setProperty('Line.Title/QosThroughput.server.app[3]', 'voice')&#10;print(chart.getProperties())&#10;print(chart.getDefaultProperties())&#10;&quot;&quot;&quot;&#10;&#10;plt.savefig('jitter_qos.png', dpi=150, transparent=True)&#10;#plt.savefig('jitter_qos_zoomed.png', dpi=150, transparent=True)&#10;&#10;" type="MatplotlibChart"/>
        <chart name="Instantaneous packet delay variation" script="import results&#10;import chart&#10;import matplotlib.pyplot as plt&#10;&#10;import solid_at_zero as saz&#10;#from solid_on_zero.py import solid_at_zero&#10;&#10;filter_string_nonqos = &quot;&quot;&quot;((module(*.server.app[0]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[1]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[2]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[3]) AND name(endToEndDelay:vector) AND file(*results/NonQos-*)))&quot;&quot;&quot;&#10;  &#10;filter_string_qos = &quot;&quot;&quot;((module(*.server.app[0]) AND name(endToEndDelay:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[1]) AND name(endToEndDelay:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[2]) AND name(endToEndDelay:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[3]) AND name(endToEndDelay:vector) AND file(*results/Qos-*)))&quot;&quot;&quot;&#10;&#10;df_nonqos = results.getVectors(filter_string_nonqos)&#10;&#10;df_nonqos = results.transform_results(df_nonqos)&#10;&#10;df_nonqos.result['vecvalue'] *= 1000&#10;&#10;df_qos = results.getVectors(filter_string_qos)&#10;&#10;df_qos = results.transform_results(df_qos)&#10;&#10;df_qos.result['vecvalue'] *= 1000&#10;&#10;&#10;&#10;modulenames = list(df_nonqos.index.get_level_values('module'))&#10;props = {'X.Axis.Min': '0.5', 'Line.Name/QosThroughput.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[3]': 'voice', 'Line.Name/QosShowcase.server.app[0]': 'background', 'Y.Axis.Title': 'End-to-end delay [s]', 'Line.Name/QosThroughput.server.app[0]': 'background', 'Line.Name/QosShowcase.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[3]': 'voice', 'Graph.Title': 'End-to-end delay, equal bitrate non-qos', 'Legend.Display': 'true', 'X.Axis.Title': 'Time [s]'}&#10;&#10;names_nonqos = [props[&quot;Line.Name/&quot; + i] for i in modulenames]&#10;&#10;# keys = [&quot;Line.Name/&quot; + i for i in modulenames]&#10;# names = [props[k] if k in props else &quot;default&quot; for k in keys]&#10;&#10;&#10;print(names_nonqos)&#10;df_nonqos[('attr','title')] = names_nonqos&#10;&#10;for i in range(0,df_nonqos.result['vecvalue'].shape[0]):&#10;    vals = df_nonqos.result['vecvalue'][i]&#10;        &#10;    difference = [vals[x] - vals[x-1] for x in range(0,len(vals))]&#10;    difference[0] = vals[0]&#10;    &#10;    df_nonqos.result['vecvalue'][i] = difference&#10;    &#10;modulenames = list(df_qos.index.get_level_values('module'))&#10;props = {'X.Axis.Min': '0.5', 'Line.Name/QosThroughput.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[3]': 'voice', 'Line.Name/QosShowcase.server.app[0]': 'background', 'Y.Axis.Title': 'End-to-end delay [s]', 'Line.Name/QosThroughput.server.app[0]': 'background', 'Line.Name/QosShowcase.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[3]': 'voice', 'Graph.Title': 'End-to-end delay, equal bitrate non-qos', 'Legend.Display': 'true', 'X.Axis.Title': 'Time [s]'}&#10;&#10;names_qos = [props[&quot;Line.Name/&quot; + i] for i in modulenames]&#10;&#10;# keys = [&quot;Line.Name/&quot; + i for i in modulenames]&#10;# names = [props[k] if k in props else &quot;default&quot; for k in keys]&#10;&#10;&#10;print(names_qos)&#10;df_qos[('attr','title')] = names_qos&#10;&#10;for i in range(0,df_qos.result['vecvalue'].shape[0]):&#10;    vals = df_qos.result['vecvalue'][i]&#10;        &#10;    difference = [vals[x] - vals[x-1] for x in range(0,len(vals))]&#10;    difference[0] = vals[0]&#10;    &#10;    df_qos.result['vecvalue'][i] = difference&#10;&#10;plt.figure(figsize=(10,4))&#10;&#10;ax1 = plt.subplot(121)&#10;for ind, row in df_nonqos.iterrows():&#10;    times = row[('result', 'vectime')]&#10;    values = row[('result', 'vecvalue')]&#10;    label = row[('attr', 'title')]&#10;    print(label)&#10;    plt.plot(times, values, linewidth=0, marker='.', markersize=2, label=label)&#10;plt.legend(loc=1, ncol=4, handletextpad=0.1, columnspacing=0.1, markerscale=4)&#10;plt.tight_layout(1.5)&#10;&#10;#ymin, ymax = plt.ylim()&#10;&#10;xmin, xmax = plt.xlim()&#10;&#10;#plt.ylim(-0.05, 0.05)&#10;#plt.ylim(-0.15, 0.15)&#10;&#10;plt.xlabel('Time [s]')&#10;plt.ylabel('Instantaneous packet delay variation [ms]')&#10;plt.title('Non-QoS')&#10;&#10;#-----------------------------------&#10;ZOOMED = True&#10;&#10;if ZOOMED:&#10;    y = 15&#10;else:&#10;    ymin, ymax = plt.ylim()&#10;    y = max(abs(ymin),abs(ymax))&#10;&#10;plt.ylim(-y,y)&#10;plt.xlim(0.5,xmax)&#10;#-----------------------------------&#10;&#10;ticklocs, ticklabels = plt.yticks()&#10;&#10;print(&quot;ticks: &quot;, ticklocs, ticklabels)&#10;&#10;#plt.yticks([0, 0.5, 1, 1.5, 2])&#10;&#10;plt.grid(b=True, which='major', axis='both', linestyle='--')&#10;&#10;ax2 = plt.subplot(122)&#10;for ind, row in df_qos.iterrows():&#10;    times = row[('result', 'vectime')]&#10;    values = row[('result', 'vecvalue')]&#10;    label = row[('attr', 'title')]&#10;    print(label)&#10;    plt.plot(times, values, linewidth=0, marker='.', markersize=2, label=label)&#10;plt.legend(loc=1, ncol=4, handletextpad=0.1, columnspacing=0.1, markerscale=4)&#10;plt.tight_layout(1.5)&#10;&#10;#ymin, ymax = plt.ylim()&#10;&#10;xmin, xmax = plt.xlim()&#10;&#10;#plt.ylim(-0.05, 0.05)&#10;#plt.ylim(-0.15, 0.15)&#10;&#10;#-----------------------------------&#10;ZOOMED = True&#10;&#10;if ZOOMED:&#10;    y = 15&#10;else:&#10;    ymin, ymax = plt.ylim()&#10;    y = max(abs(ymin),abs(ymax))&#10;&#10;plt.ylim(-y,y)&#10;plt.xlim(0.5,xmax)&#10;#-----------------------------------&#10;&#10;ticklocs, ticklabels = plt.yticks()&#10;&#10;print(&quot;ticks: &quot;, ticklocs, ticklabels)&#10;&#10;#plt.yticks([0, 0.5, 1, 1.5, 2])&#10;&#10;plt.grid(b=True, which='major', axis='both', linestyle='--')&#10;&#10;ax = plt.gca()&#10;&#10;a = ax.get_ygridlines()&#10;&#10;# get default grid color&#10;ygridlines = ax1.get_ygridlines()&#10;default_grid_color = ygridlines[0].get_color()&#10;&#10;saz.solid_at_zero(ax1,default_grid_color)&#10;saz.solid_at_zero(ax2,default_grid_color)&#10;&#10;# zoom level change event handling&#10;def on_xlims_change(axes):&#10;    print(&quot;plt.xlim&quot; + str(ax.get_xlim()))&#10;#    saz.solid_at_zero(ax,default_grid_color)&#10;&#10;def on_ylims_change(axes):&#10;    print(&quot;plt.ylim&quot; + str(ax.get_ylim()))&#10;#    saz.solid_at_zero(ax,default_grid_color)&#10;    &#10;ax1.callbacks.connect('xlim_changed', on_xlims_change)&#10;ax1.callbacks.connect('ylim_changed', on_ylims_change)&#10;ax2.callbacks.connect('xlim_changed', on_xlims_change)&#10;ax2.callbacks.connect('ylim_changed', on_ylims_change)&#10;    &#10;#change_axis(ax1,plt)&#10;#change_axis(ax2,plt)&#10;&#10;# solid line at y=0&#10;&#10;# get default grid color&#10;#ygridlines = ax.get_ygridlines()&#10;#default_grid_color = ygridlines[2].get_color()&#10;&#10;#def solid_at_zero():&#10;#    a = ax.get_ygridlines()&#10;#    ticklocs, ticklabels = plt.yticks()&#10;#    print(&quot;gridlines:&quot;,a)&#10;    &#10;#    j = 0&#10;#    r = 0&#10;    # set everything to default here&#10;#    plt.grid(linestyle='--',color=default_grid_color)&#10;    &#10;#    for i in ticklocs:&#10;#        if i == 0.0:&#10;#            #print(&quot;found 0 at &quot;,j)&#10;#            r = j&#10;#            b = a[r]&#10;#            b.set_color('black')&#10;#            b.set_linestyle('solid')&#10;#        j += 1&#10;    &#10;#solid_at_zero()&#10;&#10;#b = a[3]&#10;#b.set_color('black')&#10;#b.set_linestyle('solid')&#10;&#10;plt.xlabel('Time [s]')&#10;plt.title('QoS')&#10;#plt.ylabel('Instantaneous packet delay variation [ms]')&#10;plt.suptitle('Instantaneous packet delay variation',y=1, size=14)&#10;&quot;&quot;&quot;&#10;chart.setProperty('X.Axis.Title', 'Time')&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;chart.setProperty('Line.Title/QosThroughput.server.app[3]', 'voice')&#10;print(chart.getProperties())&#10;print(chart.getDefaultProperties())&#10;&quot;&quot;&quot;&#10;&#10;plt.savefig('jitter.png', dpi=150, transparent=True)&#10;" type="MatplotlibChart"/>
        <chart name="Throughput, non-qos" script="import results&#10;import chart&#10;import matplotlib.pyplot as plt&#10;import pandas as pd&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.server.app[0]) AND name(throughput:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[1]) AND name(throughput:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[2]) AND name(throughput:vector) AND file(*results/NonQos-*))&#10;  OR (module(*.server.app[3]) AND name(throughput:vector) AND file(*results/NonQos-*)))&quot;&quot;&quot;&#10;&#10;df = results.getVectors(filter_string)&#10;&#10;#print(&quot;DF:&quot;,df[['attrname','attrvalue']])&#10;df2 = pd.DataFrame(df, columns=['attrname','attrvalue'])&#10;#print(&quot;DF_:&quot;,df2)&#10;#print(&quot;packetname:&quot;,df2.filter(like='packetName'))&#10;&#10;#df2.str.contains('packetName')&#10;&#10;df3 = df2[df2.attrname.str.contains('packetName',na=False)]&#10;&#10;#print(&quot;contains:&quot;, df3)&#10;&#10;#df3.attrvalue.str.replace('&quot;','')&#10;&#10;#print(&quot;df3 replaced:&quot;,df3)&#10;&#10;df4 = list(df3.attrvalue)&#10;&#10;names2 = []&#10;&#10;for i in df4:&#10;    i = i.replace('&quot;','')&#10;    print(&quot;i:&quot;,i)&#10;    print(&quot;type:&quot;,type(i))&#10;    names2.append(i)&#10;    #print(&quot;names2&quot;,names2)&#10;&#10;print(&quot;just the names:&quot;, names2)&#10;&#10;#print(&quot;XX:&quot;,df.index.get_level_values('attrname'))&#10;&#10;df = results.transform_results(df)&#10;    &#10;df.result['vecvalue'] /= 1000000&#10;&#10;df[('attr','title')] = names2&#10;&#10;plt.figure(figsize=(7.5,4))&#10;&#10;for ind, row in df.iterrows():&#10;    times = row[('result', 'vectime')]&#10;    values = row[('result', 'vecvalue')]&#10;    label = row[('attr', 'title')]&#10;    print(label)&#10;    plt.plot(times, values, linewidth=1, marker='s', markersize=1, label=label)&#10;plt.legend()&#10;plt.tight_layout(1.5)&#10;&#10;ymin, ymax = plt.ylim()&#10;xmin, xmax = plt.xlim()&#10;&#10;plt.ylim(-0.1,6)&#10;plt.xlim(0.5,8)&#10;&#10;ticklocs, ticklabels = plt.yticks()&#10;&#10;print(&quot;ticks: &quot;, ticklocs, ticklabels)&#10;&#10;plt.grid(b=True, which='major', axis='both', linestyle='--')&#10;&#10;plt.xlabel('Time [s]')&#10;plt.ylabel('Application-level throughput [Mbps]')&#10;plt.title('Throughput, non-QoS')&#10;&quot;&quot;&quot;&#10;chart.setProperty('X.Axis.Title', 'Time')&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;chart.setProperty('Line.Title/QosThroughput.server.app[3]', 'voice')&#10;print(chart.getProperties())&#10;print(chart.getDefaultProperties())&#10;&quot;&quot;&quot;&#10;&#10;plt.savefig('throughput_nonqos.png', dpi=150, transparent=True)&#10;" type="MatplotlibChart"/>
        <chart name="Throughput, qos" script="import results&#10;import chart&#10;import matplotlib.pyplot as plt&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.server.app[0]) AND name(throughput:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[1]) AND name(throughput:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[2]) AND name(throughput:vector) AND file(*results/Qos-*))&#10;  OR (module(*.server.app[3]) AND name(throughput:vector) AND file(*results/Qos-*)))&quot;&quot;&quot;&#10;&#10;df = results.getVectors(filter_string)&#10;&#10;df = results.transform_results(df)&#10;    &#10;df.result['vecvalue'] /= 1000000&#10;&#10;&#10;&#10;modulenames = list(df.index.get_level_values('module'))&#10;props = {'X.Axis.Min': '0.5', 'Line.Name/QosThroughput.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[3]': 'voice', 'Line.Name/QosShowcase.server.app[0]': 'background', 'Y.Axis.Title': 'End-to-end delay [s]', 'Line.Name/QosThroughput.server.app[0]': 'background', 'Line.Name/QosShowcase.server.app[2]': 'video', 'Line.Name/QosThroughput.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[1]': 'best effort', 'Line.Name/QosShowcase.server.app[3]': 'voice', 'Graph.Title': 'End-to-end delay, equal bitrate non-qos', 'Legend.Display': 'true', 'X.Axis.Title': 'Time [s]'}&#10;&#10;names = [props[&quot;Line.Name/&quot; + i] for i in modulenames]&#10;&#10;# keys = [&quot;Line.Name/&quot; + i for i in modulenames]&#10;# names = [props[k] if k in props else &quot;default&quot; for k in keys]&#10;&#10;&#10;print(names)&#10;df[('attr','title')] = names&#10;&#10;plt.figure(figsize=(7.5,4))&#10;&#10;for ind, row in df.iterrows():&#10;    times = row[('result', 'vectime')]&#10;    values = row[('result', 'vecvalue')]&#10;    label = row[('attr', 'title')]&#10;    print(label)&#10;    plt.plot(times, values, linewidth=1, marker='s', markersize=1, label=label)&#10;plt.legend()&#10;plt.tight_layout(1.5)&#10;&#10;ymin, ymax = plt.ylim()&#10;xmin, xmax = plt.xlim()&#10;&#10;plt.ylim(-0.1,6)&#10;plt.xlim(0.5,8)&#10;&#10;ticklocs, ticklabels = plt.yticks()&#10;&#10;print(&quot;ticks: &quot;, ticklocs, ticklabels)&#10;&#10;plt.grid(b=True, which='major', axis='both', linestyle='--')&#10;&#10;plt.xlabel('Time [s]')&#10;plt.ylabel('Application-level throughput [Mbps]')&#10;plt.title('Throughput, QoS')&#10;&quot;&quot;&quot;&#10;chart.setProperty('X.Axis.Title', 'Time')&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;chart.setProperty('Line.Title/QosThroughput.server.app[3]', 'voice')&#10;print(chart.getProperties())&#10;print(chart.getDefaultProperties())&#10;&quot;&quot;&quot;&#10;&#10;plt.savefig('throughput_qos.png', dpi=150, transparent=True)" type="MatplotlibChart"/>
    </charts>
</analysis>
